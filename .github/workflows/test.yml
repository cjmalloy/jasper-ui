name: Test

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ '**' ]

permissions:
  checks: write
  contents: read
  pull-requests: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - name: Build the Docker image
        run: docker build . -t ${{ github.repository }}:$(date +%s)

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - name: Build the testing image
        run: docker build . --file Dockerfile --target test --tag test
      - name: Run the test container
        run: docker run --name test test
      - name: Copy test reports from container
        if: always()
        run: docker cp test:/report report
      - name: Upload PR Report
        if: github.event_name == 'pull_request' && always()
        uses: actions/upload-artifact@v6
        with:
          name: karma-reports-pr-${{ github.event.pull_request.number }}
          path: report
          retention-days: 7
      - name: Upload Reports
        if: github.event_name != 'pull_request' && always()
        uses: actions/upload-artifact@v6
        with:
          name: karma-reports-${{ github.ref_name }}-${{ github.run_number }}
          path: report
          retention-days: 30
      - name: Generate Test Summary
        if: always()
        uses: actions/github-script@v8
        with:
          # language=JavaScript
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Parse Karma console output
            function parseKarmaOutput(logContent) {
              let testsTotal = 0;
              let testsFailed = 0;
              let testsSkipped = 0;
              
              // Look for the Karma summary line: "Executed X of Y (Z FAILED) (skipped N)"
              // or "Executed X of Y SUCCESS"
              // or "Executed X of Y (Z FAILED)"
              const failedWithSkipMatch = logContent.match(/Executed\s+(\d+)\s+of\s+(\d+)\s+\((\d+)\s+FAILED\).*?\(skipped\s+(\d+)\)/);
              const failedMatch = logContent.match(/Executed\s+(\d+)\s+of\s+(\d+)\s+\((\d+)\s+FAILED\)/);
              const successWithSkipMatch = logContent.match(/Executed\s+(\d+)\s+of\s+(\d+)\s+SUCCESS.*?\(skipped\s+(\d+)\)/);
              const successMatch = logContent.match(/Executed\s+(\d+)\s+of\s+(\d+)\s+SUCCESS/);
              const disconnectedMatch = logContent.match(/Executed\s+(\d+)\s+of\s+(\d+)\s+\((\d+)\s+FAILED\)\s+DISCONNECTED/);
              const errorMatch = logContent.match(/Executed\s+(\d+)\s+of\s+(\d+)\s+\((\d+)\s+FAILED\)\s+ERROR/);
              
              if (disconnectedMatch || errorMatch) {
                const match = disconnectedMatch || errorMatch;
                testsTotal = parseInt(match[2]);
                testsFailed = parseInt(match[3]);
              } else if (failedWithSkipMatch) {
                testsTotal = parseInt(failedWithSkipMatch[2]);
                testsFailed = parseInt(failedWithSkipMatch[3]);
                testsSkipped = parseInt(failedWithSkipMatch[4]);
              } else if (failedMatch) {
                testsTotal = parseInt(failedMatch[2]);
                testsFailed = parseInt(failedMatch[3]);
              } else if (successWithSkipMatch) {
                testsTotal = parseInt(successWithSkipMatch[2]);
                testsFailed = 0;
                testsSkipped = parseInt(successWithSkipMatch[3]);
              } else if (successMatch) {
                testsTotal = parseInt(successMatch[2]);
                testsFailed = 0;
              }
              
              return {
                testsTotal,
                testsFailed,
                testsSkipped
              };
            }
            
            let summary = '## üß™ Test Results\n\n';
            
            try {
              const logPath = 'report/test-output.log';
              if (fs.existsSync(logPath)) {
                const logContent = fs.readFileSync(logPath, 'utf8');
                const results = parseKarmaOutput(logContent);
                
                if (results.testsTotal > 0) {
                  const testsPassed = results.testsTotal - results.testsFailed - results.testsSkipped;
                  const emoji = results.testsFailed === 0 ? '‚úÖ' : '‚ö†Ô∏è';
                  
                  summary += `${emoji} **Tests:** ${results.testsFailed} failed | ${testsPassed} passed`;
                  if (results.testsSkipped > 0) {
                    summary += ` | ${results.testsSkipped} skipped`;
                  }
                  summary += ` (${results.testsTotal} total)\n\n`;
                  
                  if (results.testsFailed === 0) {
                    summary += 'üéâ All tests passed!\n\n';
                  } else {
                    const passRate = ((testsPassed / results.testsTotal) * 100).toFixed(1);
                    summary += `üìä **Pass Rate:** ${passRate}%\n\n`;
                  }
                } else {
                  summary += '‚ö†Ô∏è No test results found in log output.\n\n';
                }
              } else {
                summary += '‚ö†Ô∏è Test output log not found.\n\n';
              }
            } catch (error) {
              summary += `‚ö†Ô∏è Error parsing test results: ${error.message}\n\n`;
            }
            
            // Write summary to GitHub Step Summary
            await core.summary
              .addRaw(summary)
              .write();
            
            // Store summary for use in PR comment
            fs.writeFileSync('test-summary.md', summary);
      - name: Comment on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v8
        with:
          # language=JavaScript
          script: |
            const fs = require('fs');
            
            let summary = '';
            try {
              summary = fs.readFileSync('test-summary.md', 'utf8');
            } catch (error) {
              summary = '‚ö†Ô∏è Could not read test summary.';
            }
            
            const reportUrl = `https://${context.repo.owner}.github.io/${context.repo.repo}/reports/karma-reports-pr-${context.issue.number}/`;
            summary += `\n\nüìä [View detailed HTML report](${reportUrl})`;
            
            // Add HTML comment marker for identification
            const body = `<!-- test-results-comment -->\n${summary}`;
            
            // Find existing comment (with pagination)
            const comments = await github.paginate(github.rest.issues.listComments, {
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const botComment = comments.find(comment => 
              comment.body.includes('<!-- test-results-comment -->')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

  clean:
    needs: test
    if: always()
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Cleanup old artifacts
        if: github.event_name != 'pull_request'
        uses: actions/github-script@v8
        with:
          # language=JavaScript
          script: |
            const maxVersions = 3;
            const response = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            const artifacts = response.data.artifacts
              .filter(artifact => artifact.name.startsWith('karma-reports-' + '${{ github.ref_name }}'));
            if (artifacts.length > maxVersions) {
              // Sort by created_at descending
              artifacts.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              // Delete all but the latest maxVersions
              for (const artifact of artifacts.slice(maxVersions)) {
                console.log('Deleting artifact:', artifact.name);
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id
                });
              }
            }
