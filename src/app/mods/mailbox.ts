import { filter, maxBy, uniq } from 'lodash-es';
import { DateTime } from 'luxon';
import { Plugin } from '../model/plugin';
import { Ref } from '../model/ref';
import { Mod } from '../model/tag';
import { Template } from '../model/template';
import { userAuthors } from '../util/format';
import {
  access,
  hasPrefix,
  hasTag,
  localTag,
  prefix,
  removeParentOrigin,
  removePrefix,
  setPublic,
  subOrigin,
  tagOrigin
} from '../util/tag';

export const dmTemplate: Template = {
  tag: 'dm',
  name: $localize`ðŸ“¨ï¸ DM`,
  config: {
    mod: 'ðŸ“®ï¸ Mailbox',
    default: true,
    genId: true,
    internal: true,
    reply: ['dm', 'internal', 'plugin/thread'],
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`Adds dms tab to inbox. Adds buttons to create private direct messages with users.`,
    aiInstructions: `# dm
    The dm tag indicates the Ref represents a private direct message.`,
    icons: [
      { tag: '!public', thumbnail: $localize`ðŸ“¨ï¸`, title: $localize`Direct Message`, order: 1 },
      { tag: 'public', thumbnail: $localize`ðŸ“ï¸`, title: $localize`Memo`, order: 1 },
      { tag: 'internal', thumbnail: $localize`ðŸ“¨ï¸`, title: $localize`DM Thread`, order: 2 },
    ],
    filters: [
      { query: 'dm', label: $localize`ðŸ“¨ï¸ dm`, title: $localize`DMs`, group: $localize`Templates ðŸŽ¨ï¸` },
    ],
  },
};

export const inboxPlugin: Plugin = {
  tag: 'plugin/inbox',
  name: $localize`âœ‰ï¸ Inbox`,
  config: {
    mod: 'ðŸ“®ï¸ Mailbox',
    default: true,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`'The inbox plugin allow sending notifications to another user
      on the same server.'`,
    readAccess: ['plugin/inbox'],
  },
};

export const outboxPlugin: Plugin = {
  tag: 'plugin/outbox',
  name: $localize`ðŸ“¬ï¸ Outbox`,
  config: {
    mod: 'ðŸ“®ï¸ Mailbox',
    default: true,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`The outbox plugin allow sending notifications to another user on a remote server.`,
    icons: [{ label: $localize`ðŸ“¬ï¸`, title: $localize`Notifications in outbox`, order: -2 }],
    filters: [
      { query: 'plugin/outbox', label: $localize`ðŸ“¬ï¸ outbox`, title: $localize`Messages from another server`, group: $localize`Plugins ðŸ§°ï¸` },
    ],
  },
};

export function isMailbox(tag: string) {
  return tag.startsWith('plugin/inbox') ||
    tag.startsWith('plugin/outbox');
}

export function notifications(ref: Ref): string[] {
  return filter(ref.tags || [], isMailbox);
}

export function addressedTo(ref: Ref): string[] {
  return notifications(ref).map(mailbox => getUser(mailbox, ref.origin || '')).filter(u => u) as string[];
}

export function getUser(mailbox: string, localOrigin: string): string | undefined {
  const tag = getMailboxTag(mailbox, localOrigin);
  if (!tag) return tag;
  if (mailbox.startsWith('_')) return '_' + tag;
  if (tag == 'user') return '+user';
  if (tag.startsWith('user/')) return '+' + tag;
  return tag;
}

export function getMailboxTag(mailbox: string, localOrigin: string): string | undefined {
  if (mailbox.startsWith('_plugin/inbox/')) return mailbox.substring('_plugin/inbox/'.length) + localOrigin;
  if (mailbox.startsWith('plugin/inbox/')) return mailbox.substring('plugin/inbox/'.length) + localOrigin;
  if (mailbox.startsWith('_plugin/outbox/')) return reverseOrigin(mailbox.substring('_plugin/outbox/'.length), localOrigin);
  if (mailbox.startsWith('plugin/outbox/')) return reverseOrigin(mailbox.substring('plugin/outbox/'.length), localOrigin);
  if (mailbox.startsWith('_plugin/from/')) return reverseOrigin(mailbox.substring('_plugin/from/'.length), localOrigin);
  if (mailbox.startsWith('plugin/from/')) return reverseOrigin(mailbox.substring('plugin/from/'.length), localOrigin);
  return undefined;
}

/**
 * Convert from reverse origin syntax (origin/tag) to qualified tag syntax (tag@origin).
 */
export function reverseOrigin(tag: string, rootOrigin: string): string {
  let prefix = access(tag);
  if (prefix) tag = tag.substring(1);
  const len = tag.indexOf('/');
  return prefix + tag.substring(len + 1) + subOrigin(rootOrigin, tag.substring(0, len));
}

export function getMailbox(tag: string, local: string): string {
  if (hasPrefix(tag, 'plugin/inbox') || hasPrefix(tag, 'plugin/outbox')) return localTag(tag);
  const origin = tagOrigin(tag);
  if (!origin || origin === local) {
    return setPublic(prefix('plugin/inbox', localTag(tag)));
  } else {
    return setPublic(prefix(`plugin/outbox/${removeParentOrigin(origin, local).substring(1)}`, localTag(tag)));
  }
}

export function getLocalMailbox(mailbox: string, local: string, origin: string, lookup?: Map<string, Map<string, string>>) {
  if (!origin || origin === local) return localTag(mailbox);
  if (hasPrefix(mailbox, 'plugin/outbox')) {
    if (!lookup?.has(origin)) {
      console.warn('Cannot lookup mailbox translation for', origin);
      return undefined;
    }
    const remote = '@' + mailbox.split('/')[2];
    if (!lookup.get(origin)!.has(remote)) {
      console.warn('Cannot lookup mailbox translation for', origin, 'on remote', remote);
      return undefined;
    }
    const mapped = lookup.get(origin)!.get(remote);
    if (!mapped || mapped === local) {
      return `plugin/inbox/${removePrefix(mailbox, 3)}`;
    }
    return `plugin/outbox/${mapped.substring(1)}/${removePrefix(mailbox, 3)}`;
  }
  if (hasPrefix(mailbox, 'plugin/inbox')) {
    return `plugin/outbox/${origin.substring(1)}/${removePrefix(mailbox, 2)}`;
  }
  throw 'not a mailbox';
}

export function mailboxes(ref: Ref, myUserTag: string, lookup?: Map<string, Map<string, string>>): string[] {
  const local = tagOrigin(myUserTag);
  return uniq([
    ...userAuthors(ref).filter(tag => tag !== myUserTag).map(tag => getMailbox(tag, local)),
    ...hasTag('public', ref)
      ? []
      : userAuthors(ref)
        .filter(tag => hasPrefix(tag, 'user') && (tagOrigin(tag) === local || !tagOrigin(tag)))
        .map(tag => tag.startsWith('+') ? localTag(tag).substring(1) : localTag(tag)),
    ...notifications(ref).map(m => getLocalMailbox(m, local, ref.origin || '', lookup)).filter(t => !!t) as string[],
  ]);
}

export function newest(refs: Ref[]) {
  return maxBy(refs, r => r.modified!.valueOf());
}

export const mailboxMod: Mod = {
  plugin: [
    inboxPlugin,
    outboxPlugin,
  ],
   template: [
    dmTemplate,
  ],
};
