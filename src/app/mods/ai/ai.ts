import { DateTime } from 'luxon';
import { Plugin } from '../../model/plugin';
import { Mod } from '../../model/tag';

export const aiQueryPlugin: Plugin = {
  tag: 'plugin/delta/ai',
  name: $localize`✨️💭️ AI Query`,
  config: {
    mod: $localize`✨️ AI Generation`,
    type: 'tool',
    default: false,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`Send this Ref to the ai for response.`,
    timeoutMs: 300_000,
    language: 'javascript',
    // language=JavaScript
    script: `
      const DEFAULT_PROVIDER = 'gemini';
      const { Buffer } = require('buffer');
      const uuid = require('uuid');
      const axios = require('axios');
      const ref = JSON.parse(require('fs').readFileSync(0, 'utf-8'));
      const origin = ref.origin || '';
      const matchesTag = (prefix, tag) => prefix === tag || tag.startsWith(prefix + '/');
      const hasTag = (tag, ref) => ref.tags?.find(t => matchesTag(tag, t));
      const followup = hasTag('+plugin/delta/ai', ref);
      const authors = ref.tags.filter(tag => tag === '+user' || tag === '_user' || tag.startsWith('+user/') || tag.startsWith('_user/'));
      const response = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
        headers: {
          'Local-Origin': origin || 'default',
          'User-Tag': authors[0] || '',
        },
        params: {
          query: '+plugin/placeholder:!+plugin/delta:' + authors.map(a => a.substring(1)).join(':') + ':' + (origin || '@'),
          responses: ref.url,
          size: 1,
        },
      })).data.content[0];
      if (!response) {
        // No placeholder, earlier stage failed
        process.exit(0);
      }
      const config = {
        ...ref.plugins?.['plugin/llm'] || {},
        ...response.plugins?.['plugin/llm'] || {},
      };
      config.vision ||= hasTag('plugin/image', ref) || hasTag('plugin/video', ref);
      config.audio ||= hasTag('plugin/audio', ref);
      config.pdf ||= hasTag('plugin/pdf', ref);
      config.search ||= hasTag('plugin/llm/search', ref);
      config.url ||= hasTag('plugin/llm/search', ref);
      const fullBundleSchema = {
        type: 'object',
        properties: {
          ref: {
            type: 'array',
            minItems: 1,
            items: {
              type: 'object',
              properties: {
                url: { type: 'string' },
                title: { type: 'string' },
                comment: { type: 'string' },
                tags: { type: 'array', items: { type: 'string' } },
                sources: { type: 'array', items: { type: 'string' } },
                alternateUrls: { type: 'array', items: { type: 'string' } },
                plugins: { type: 'object' },
                published: { type: 'string' },
              }
            }
          },
          ext: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                tag: { type: 'string' },
                name: { type: 'string' },
                config: { type: 'object' },
              },
              required: ['tag']
            }
          }
        }
      };
      const bundleSchema = {
        type: 'object',
        properties: {
          ref: {
            type: 'array',
            minItems: 1,
            maxItems: 1,
            items: {
              type: 'object',
              properties: {
                title: { type: 'string' },
                comment: { type: 'string' },
              }
            }
          }
        }
      };
      const formatMessage = source => {
        if (config.json) {
          return JSON.stringify(source);
        } else {
          return (source.title ? source.title + ':' : '') + source.comment;
        }
      };
      const providers = {
        openai: {
          init(config) {
            config.model ||= config.vision ? 'gpt-5' : config.audio ? 'gpt-4o-audio-preview' : 'gpt-5';
            config.maxTokens ||= 4096;
            config.thinking = false;
            config.pdf = false;
            config.image = ['gpt-5', 'gpt-5-mini', 'gpt-5-nano'].includes(config.model);
            config.audio = ['gpt-4o-audio-preview', 'gpt-4o-mini-audio-preview'].includes(config.model);
            config.video = false;
          },
          loadMessage(source, plugins = {}) {
            const message = {};
            message.content = [{ type: 'input_text', text: formatMessage(source) }];
            if (plugins['plugin/audio']) {
              message.content.push({
                type: 'input_audio',
                input_audio: {
                  data: Buffer.from(plugins['plugin/audio'].data, 'binary').toString('base64'),
                  format: plugins['plugin/audio'].headers['content-type'] === 'audio/mpeg' ? 'mp3' :
                          plugins['plugin/audio'].headers['content-type'] === 'audio/wav'  ? 'wav' : 'mp3',
                }
              });
            }
            if (plugins['plugin/image']) {
              message.content.push({
                type: 'input_image',
                image_url: 'data:' + (plugins['plugin/image'].headers['content-type'] || 'image/png') + ';base64,' + Buffer.from(plugins['plugin/image'].data, 'binary').toString('base64'),
              });
            }
            return message;
          },
          async generate(messages, config) {
            const OpenAi = require('openai');
            const openai = new OpenAi({ apiKey });
            const res = await openai.responses.create({
              model: config.model,
              input: messages,
              text: {
                format: { 'type': config.search || config.audio || !config.json ? 'text' : 'json_object' },
              },
              tools: config.search ? [{ type: 'web_search' }] : undefined,
              max_output_tokens: config.maxTokens,
            });
            return {
              res,
              completion: res.output_text,
              usage: {
                prompt_tokens: res.usage?.input_tokens,
                completion_tokens: res.usage?.output_tokens,
                total_tokens: res.usage?.total_tokens,
              },
            };
          }
        },
        x: {
          init(config) {
            config.model ||= 'grok-4';
            config.maxTokens ||= 4096;
            config.thinking = false;
            config.pdf = false;
            config.image = ['grok-4', 'grok-2-vision-latest'].includes(config.model);
            config.audio = false;
            config.video = false;
          },
          loadMessage(source, plugins = {}) {
            const message = {};
            message.content = [{ type: 'text', text: formatMessage(source) }];
            if (plugins['plugin/audio']) {
              message.content.push({
                type: 'input_audio',
                input_audio: {
                  data: Buffer.from(plugins['plugin/audio'].data, 'binary').toString('base64'),
                  format: plugins['plugin/audio'].headers['content-type'] === 'audio/mpeg' ? 'mp3' :
                    plugins['plugin/audio'].headers['content-type'] === 'audio/wav'  ? 'wav' : 'mp3',
                }
              });
            }
            if (plugins['plugin/image']) {
              message.content.push({
                type: 'image_url',
                image_url: {
                  url: 'data:' + plugins['plugin/image'].headers['content-type'] + ';base64,' + Buffer.from(plugins['plugin/image'].data, 'binary').toString('base64'),
                  detail: 'auto',
                }
              });
            }
            return message;
          },
          async generate(messages, config) {
            const OpenAi = require('openai');
            const openai = new OpenAi({ apiKey, baseURL: 'https://api.x.ai/v1' });
            const res = await openai.chat.completions.create({
              model: config.model,
              max_completion_tokens: config.maxTokens,
              response_format: { 'type': config.json ? 'json_object' : 'text' },
              search_parameters: { mode: config.search ? 'on' : 'off' },
              messages,
            });
            return {
              res,
              completion: res.choices[0]?.message?.content,
              usage: res.usage,
            };
          }
        },
        nous: {
          init(config) {
            config.model ||= 'DeepHermes-3-Llama-3-8B-Preview';
            config.maxTokens ||= 4096;
            config.thinking = false;
            config.pdf = false;
            config.image = false;
            config.audio = false;
            config.video = false;
            config.search = false;
          },
          loadMessage(source, plugins = {}) {
            return providers['x'].loadMessage(source, plugins);
          },
          async generate(messages, config) {
            const OpenAi = require('openai');
            const openai = new OpenAi({ apiKey, baseURL: 'https://inference-api.nousresearch.com/v1' });
            const res = await openai.chat.completions.create({
              model: config.model,
              max_completion_tokens: config.maxTokens,
              response_format: { 'type': config.json ? 'json_object' : 'text' },
              messages,
            });
            return {
              res,
              completion: res.choices[0]?.message?.content,
              usage: res.usage,
            };
          }
        },
        ds: {
          init(config) {
            config.model ||= config.thinking ? 'deepseek-reasoner' : 'deepseek-chat';
            config.maxTokens ||= 4096;
            config.thinking = config.model === 'deepseek-reasoner';
            config.image = false;
            config.audio = false;
            config.video = false;
            config.search = false;
          },
          loadMessage(source, plugins = {}) {
            return providers['x'].loadMessage(source, plugins);
          },
          async generate(messages, config) {
            const OpenAi = require('openai');
            const openai = new OpenAi({ apiKey, baseURL: 'https://api.deepseek.com' });
            const res = await openai.chat.completions.create({
              model: config.model,
              max_completion_tokens: config.maxTokens,
              response_format: (!config.json || config.thinking) ? undefined : { 'type': 'json_object' },
              messages,
            });
            return {
              res,
              completion: res.choices[0]?.message?.content,
              usage: res.usage,
            };
          }
        },
        anthropic: {
          init(config) {
            config.model ||= 'claude-opus-4-1';
            config.maxTokens ||= 4096;
            config.thinkingTokens ||= 4096
            config.pdf = true;
            config.image = true;
            config.audio = false;
            config.video = false;
            if (config.thinking) config.json = false;
          },
          loadMessage(source, plugins = {}) {
            const message = {};
            message.content = [{
              type: 'text',
              text: formatMessage(source),
            }];
            if (plugins['plugin/pdf']) {
              message.content.push({
                type: 'document',
                source: {
                  type: 'base64',
                  media_type: plugins['plugin/pdf'].headers['content-type'] || 'application/pdf',
                  data: Buffer.from(plugins['plugin/pdf'].data, 'binary').toString('base64'),
                },
                cache_control: { type: 'ephemeral' },
              });
            }
            if (plugins['plugin/image']) {
              message.content.push({
                type: 'image',
                source: {
                  type: 'base64',
                  media_type: plugins['plugin/image'].headers['content-type'] || 'image/png',
                  data: Buffer.from(plugins['plugin/image'].data, 'binary').toString('base64'),
                },
                cache_control: { type: 'ephemeral' },
              });
            }
            return message;
          },
          async generate(messages, config) {
            const Anthropic = require('@anthropic-ai/sdk');
            const anthropic = new Anthropic({ apiKey });
            const system = messages.filter(m => m.role === 'system').map(m => m.content).join("\\n\\n");
            const thinking = config.thinking ? {
              thinking: {
                type: 'enabled',
                budget_tokens: config.thinkingTokens,
              }
            } : {};
            const toolUse = {
              tools: [],
            };
            if (config.search) {
              toolUse.tools.push({
                type: 'web_search_20250305',
                name: 'web_search',
                max_uses: 10,
              });
            }
            if (config.json) {
              toolUse.tools.push({
                name: 'bundle',
                description: 'JSON responses in bundle format',
                input_schema: config.bundle ? fullBundleSchema : bundleSchema,
              });
              if (config.search) {
                toolUse.tool_choice = { type: 'any' };
              } else {
                toolUse.tool_choice = { type: 'tool', name: 'bundle' };
              }
            }
            const res = await anthropic.messages.create({
              model: config.model,
              max_tokens: config.maxTokens + (config.thinking ? config.thinkingTokens : 0),
              system,
              ...thinking,
              ...toolUse,
              messages: messages.filter(m => m.role !== 'system'),
            });
            const text = res.content.filter(t => t.type === 'text').map(t => t.text).join('');
            const tools = res.content.filter(t => t.type === 'tool_use' && t.name === 'bundle');
            return {
              res,
              completion: config.json ? JSON.stringify(tools[0]?.input || { comment: text|| '' }) : text,
              usage: {
                'prompt_tokens': res.usage.input_tokens,
                'completion_tokens': res.usage.output_tokens,
                'total_tokens': res.usage.input_tokens + res.usage.output_tokens,
              },
            };
          }
        },
        gemini: {
          init(config) {
            config.model ||= (config.pdf || config.search || config.url) ? 'gemini-2.5-pro' : 'gemini-2.5-flash';
            config.pdf = config.model === 'gemini-2.5-pro';
            config.image = true;
            config.audio = true;
            config.video = true;
            config.embed = config.url && ['gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-2.5-flash-lite', 'gemini-live-2.5-flash-preview'].includes(config.model);
            if (config.search) config.json = false;
          },
          loadMessage(source, plugins = {}) {
            const message = {};
            message.parts = [{ text: formatMessage(source) }];
            if (plugins['plugin/embed']) {
              if (plugins['plugin/embed'].startsWith('https://www.youtube.com/')) {
                message.parts.push({
                  fileData: {
                    fileUri: plugins['plugin/embed'],
                  },
                });
              } else {
                // Let gemini detect urls
              }
            }
            if (plugins['plugin/pdf']) {
              message.parts.push({
                inlineData: {
                  mimeType: plugins['plugin/pdf'].headers['content-type'] || 'application/pdf',
                  data: Buffer.from(plugins['plugin/pdf'].data, 'binary').toString('base64'),
                }
              });
            }
            if (plugins['plugin/audio']) {
              message.parts.push({
                inlineData: {
                  mimeType: plugins['plugin/audio'].headers['content-type'] || 'image/mpeg',
                  data: Buffer.from(plugins['plugin/audio'].data, 'binary').toString('base64'),
                }
              });
            }
            if (plugins['plugin/video']) {
              message.parts.push({
                inlineData: {
                  mimeType: plugins['plugin/video'].headers['content-type'] || 'video/mp4',
                  data: Buffer.from(plugins['plugin/video'].data, 'binary').toString('base64'),
                }
              });
            }
            if (plugins['plugin/image']) {
              message.parts.push({
                inlineData: {
                  mimeType: plugins['plugin/image'].headers['content-type'] || 'image/png',
                  data: Buffer.from(plugins['plugin/image'].data, 'binary').toString('base64'),
                }
              });
            }
            return message;
          },
          async generate(messages, config) {
            const { GoogleGenerativeAI } = require('@google/generative-ai');
            const genAI = new GoogleGenerativeAI(apiKey);
            const system = messages.filter(m => m.role === 'system').map(m => m.parts[0].text).join("\\n\\n");
            const model = genAI.getGenerativeModel({ model: config.model });
            const res = await model.generateContent({
              contents: messages.filter(m => m.role !== 'system').map(m => {
                if (m.role === 'assistant') m.role = 'model';
                return m;
              }),
              systemInstruction: system,
              tools: [
                ...config.search ? [{ googleSearch: {} }] : [],
                ...config.embed ? [{ urlContext: {} }] : [],
              ],
            });
            let text = res.response.text().trim();
            if (config.json) {
              while (text && !text.startsWith('{')) text = text.substring(1).trim();
              while (text && !text.endsWith('}')) text = text.substring(0, text.length - 1).trim();
              if (!text) {
                config.json = false;
                text = res.response.text().trim();
              }
            }
            return {
              res,
              completion: text,
              usage: {
                prompt_tokens: res.response.usageMetadata.promptTokenCount,
                completion_tokens: res.response.usageMetadata.candidatesTokenCount,
                total_tokens: res.response.usageMetadata.totalTokenCount,
              },
            };
          }
        },
      };
      const provider = providers[config.provider ||= DEFAULT_PROVIDER];
      provider.init(config);
      const apiKey = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
        headers: {
          'Local-Origin': origin || 'default',
          'User-Role': 'ROLE_ADMIN',
        },
        params: { query: (config.apiKeyTag ||= ('+plugin/secret/' + config.provider)) + (origin || '@') },
      })).data.content[0]?.comment;
      const messages = [];
      const systemPrompts = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
        headers: {
          'Local-Origin': origin || 'default',
          'User-Tag': authors[0] || '',
        },
        params: {
          query: '+system/prompt' + (origin || '@'),
          sources: response.url,
          sort: 'published',
          size: response.sources.length,
        },
      })).data.content;
      for (const c of systemPrompts) {
        if (c.url === 'system:ext-prompt') continue; // Placeholder
        if (config.systemPrompt && c.url === 'system:app-prompt') continue; // Overridden by config.systemPrompt
        messages.push({
          role: 'system',
          ...provider.loadMessage(c),
        });
      }
      if (response.sources.includes('system:ext-prompt')) {
        const exts = new Map();
        const getExt = async tag => {
          try {
            return (await axios.get(process.env.JASPER_API + '/api/v1/ext', {
              headers: {
                'Local-Origin': origin || 'default',
                'User-Tag': authors[0] || '',
              },
              params: { tag: tag + origin },
            })).data;
          } catch (e) {
            return null;
          }
        };
        const loadTags = async tags => {
          for (const t of tags || []) {
            if (exts.has(t)) continue;
            // TODO: handle missing ext error?
            const ext = await getExt(t);
            if (ext) exts.set(t, ext);
          }
        }
        await loadTags(response.tags);
        await loadTags(response.sources.filter(t => t.startsWith('tag:/')).map(t => t.substring('tag:/'.length)));
        if (exts.length) {
          messages.push({
            role: 'system',
            ...provider.loadMessage({ url: 'system:ext-prompt', origin, title: 'Ext Sources', comment: JSON.stringify(exts) }),
          });
        }
      }
      if (config.systemPrompt) {
        messages.push({
          role: 'system',
          ...provider.loadMessage({ url: 'system:app-prompt-override', origin, title: 'App Prompt Override', comment: config.systemPrompt }),
        });
      }
      const folderTags = (ref.tags || []).filter(t => t === 'folder' || t.startsWith('folder/'))
      if (folderTags.length) {
        const workspace = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
          headers: {
            'Local-Origin': origin || 'default',
            'User-Tag': authors[0] || '',
          },
          params: {
            query: folderTags.join(':') + (origin || '@'),
            sort: 'published,desc',
            size: config.maxSources || 2000,
          },
        })).data.content.reverse();
        for (const w of workspace) {
          const role
            = hasTag('+system/prompt', w) ? 'system'
            : hasTag('+plugin/delta/ai', w) ? 'assistant'
            : 'user';
          messages.push({
            role,
            ...provider.loadMessage(w),
          });
        }
      }
      const sources = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
        headers: {
          'Local-Origin': origin || 'default',
          'User-Tag': authors[0] || '',
        },
        params: {
          query: '!+system/prompt',
          sources: response.url,
          sort: 'published',
          size: response.sources.length,
        },
      })).data.content;
      for (const c of sources) {
        if (config.ignoreThread && ref.sources && c.url === ref.sources[1] && ref.sources[0] !== ref.sources[1]) continue;
        const plugins = {};
        if (config.embed && hasTag('plugin/embed', c)) {
          plugins['plugin/embed'] = c.plugins?.['plugin/embed']?.url || c.url;
        }
        if (config.pdf && hasTag('plugin/pdf', c)) {
          const url = c.plugins?.['plugin/pdf']?.url || c.url;
          plugins['plugin/pdf'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        if (config.image && hasTag('plugin/image', c)) {
          const url = c.plugins?.['plugin/image']?.url || c.url;
          plugins['plugin/image'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        if (config.audio && hasTag('plugin/audio', c)) {
          const url = c.plugins?.['plugin/audio']?.url || c.url;
          plugins['plugin/audio'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        if (config.video && hasTag('plugin/video', c)) {
          const url = c.plugins?.['plugin/video']?.url || c.url;
          plugins['plugin/video'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        messages.push({
          role: hasTag('+plugin/delta/ai', c) ? 'assistant' : 'user',
          ...provider.loadMessage(c, plugins),
        });
      }
      let { completion, usage, res } = await provider.generate(messages, config);
      const debugLogs = () => {
        return '\`\`\`json\\n' + JSON.stringify([...messages.map(m => {
          if (m.content && config.json) {
            m.content = m.content.map(c => {
              if (c.type === 'text') {
                c.text = JSON.parse(c.text);
              }
              return c;
            });
          }
          return m;
        }), res], null, 2) + '\\n\`\`\`';
      };
      let bundle;
      if (!completion) {
        if (hasTag('+plugin/debug', ref)) {
          throw 'Error: No completion in response:\\n' + debugLogs();
        }
        throw 'Error: No completion in response'
      }
      if (config.json) {
        try {
          bundle = JSON.parse(completion);
          if (!bundle.ref) {
            // Model returned a bare Ref?
            bundle = {
              ref: [bundle],
            };
          }
        } catch (e) {
          console.error('Error parsing completion:', e);
          console.error(completion);
          if (hasTag('+plugin/debug', ref)) {
            console.error(debugLogs());
          }
          process.exit(1);
        }
      } else {
        bundle = {
          ref: [{
            title: response.title,
            comment: completion,
          }],
        };
      }
      const completionRef = bundle.ref[0];
      if (!completionRef) {
        console.error('No ref');
        console.error(completion);
        if (hasTag('+plugin/debug', ref)) {
          console.error(debugLogs());
        }
        process.exit(1);
      }
      bundle.ref[0] = response;
      delete response.metadata;
      if (!completionRef.url?.startsWith('ai:')) completionRef.url = 'ai:' + uuid.v4();
      response.title = completionRef.title || '';
      response.comment = completionRef.comment || '';
      response.tags.push('plugin/llm');
      response.plugins ||= {};
      response.plugins['plugin/llm'] = {
        provider: config.provider,
        model: config.model,
        json: config.json,
        maxTokens: config.maxTokens,
        thinking: config.thinking,
        thinkingTokens: config.thinkingTokens,
        vision: config.vision,
        audio: config.audio,
        usage: {
          promptTokens: usage.prompt_tokens,
          completionTokens: usage.completion_tokens,
          totalTokens: usage.total_tokens,
        },
      };
      if (config.search) {
        response.tags.push('plugin/llm/search');
      }
      const chatTags = ref.tags.filter(t => t === 'chat' || t.startsWith('chat/'));
      if (!chatTags.length) {
        const mailboxes = ref.tags.filter(tag => tag.startsWith('plugin/inbox') || tag.startsWith('plugin/outbox'));
        response.tags.push(...mailboxes, ...authors.map(tag => 'plugin/inbox/' + tag.substring(1)));
      }
      response.tags.push(...ref.tags.filter(t => matchesTag('plugin/delta/ai', t)).map(t => '+' + t));
      const uniq = (v, i, a) => a.indexOf(v) === i;
      response.tags = [...response.tags, ...completionRef.tags || [], '+plugin/delta/ai'].filter(uniq).filter(t => t !== '+plugin/placeholder');
      if (followup && hasTag('plugin/delta/ai', response)) {
        // Only allow one cycle of follow-ups
        response.tags = response.tags.filter(t => !matchesTag('plugin/delta/ai', t));
      }
      response.sources = [...response.sources, ...(completionRef.sources || []).filter(uniq).filter(s => !response.sources.includes(s))];
      // TODO: Allow AI to add some protected tags
      const publicTagRegex = /^[a-z0-9]+(?:[./][a-z0-9]+)*$/;
      for (let i = 0; i < bundle.ref.length; i++) {
        const r = bundle.ref[i];
        if (i) {
          if (hasTag('dm', r)) r.tags.push('plugin/thread');
          if (hasTag('plugin/thread', r)) r.tags.push('internal');
          if (hasTag('plugin/comment', r)) r.tags.push('internal');
        }
        r.tags = (r.tags || [])
          .filter(t => publicTagRegex.test(t) || t === '+plugin/delta/ai' || t.startsWith('+plugin/delta/ai'))
          .filter(uniq);
        delete r.metadata;
        const oldUrl = i === 0 ? completionRef.url : r.url;
        // TODO: only replace comment: urls
        if (oldUrl && (oldUrl.startsWith('http:') || oldUrl.startsWith('https:'))) continue;
        const newUrl = i === 0 ? r.url : r.url = 'ai:' + uuid.v4();
        if (!oldUrl) continue;
        for (const rewrite of bundle.ref) {
          for (let i = 0; i < rewrite.sources?.length; i++) {
            if (rewrite.sources[i] === oldUrl) rewrite.sources[i] = newUrl;
          }
          if (rewrite.comment) {
            rewrite.comment = rewrite.comment
              .replaceAll('](' + oldUrl + ')', '](' + newUrl + ')')
              .replaceAll('](/ref/' + oldUrl + ')', '](/ref/' + newUrl + ')')
              .replaceAll('url=' + oldUrl, 'url=' + newUrl)
              .replaceAll('sources/' + oldUrl, 'sources/' + newUrl)
              .replaceAll('responses/' + oldUrl, 'responses/' + newUrl)
              .replaceAll('sources%2F' + oldUrl, 'sources%2F' + newUrl)
              .replaceAll('responses%2F' + oldUrl, 'responses%2F' + newUrl);
          }
        }
      }
      if (hasTag('+plugin/debug', ref)) {
        // console.error('\`\`\`json\\n' + debugJson + '\\n\`\`\`');
        bundle.ref.push({
          url: 'log:' + uuid.v4(),
          sources: [response.url],
          title: 'Debugging sources',
          comment: debugLogs(),
          tags: ['internal', '+plugin/log'],
        });
      }
      console.log(JSON.stringify(bundle));
    `,
  },
};

export const aiPlugin: Plugin = {
  tag: '+plugin/delta/ai',
  name: $localize`✨️ AI Response`,
  config: {
    mod: $localize`✨️ AI Generation`,
    type: 'tool',
    default: false,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
  },
};

export const llmPlugin: Plugin = {
  tag: 'plugin/llm',
  name: $localize`✨️ LLM Config`,
  config: {
    mod: $localize`✨️ AI Generation`,
    type: 'tool',
    default: false,
    inherit: true,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    icons: [
      { tag: '+plugin/placeholder', label: $localize`⏳️`, title: $localize`Responding...` },
    ],
    // language=Handlebars
    infoUi: `{{#if usage}}<span style="user-select:none;cursor:zoom-in" title="{{model}}: {{usage.totalTokens}} ({{usage.promptTokens}} + {{usage.completionTokens}})">ℹ️ ({{provider}})</span>{{/if}}`,
    form: [{
      key: 'provider',
      type: 'select',
      props: {
        label: $localize`Provider:`,
        options: [
          { value: 'openai', label: $localize`OpenAI` },
          { value: 'anthropic', label: $localize`Anthropic` },
          { value: 'x', label: $localize`xAI` },
          { value: 'gemini', label: $localize`Gemini` },
          { value: 'ds', label: $localize`Deep Seek` },
          { value: 'nous', label: $localize`Nous` },
        ],
      },
    }],
    advancedForm: [{
      key: 'audio',
      type: 'boolean',
      defaultValue: false,
      props: {
        label: $localize`Audio`,
      },
    }, {
      key: 'vision',
      type: 'boolean',
      defaultValue: false,
      props: {
        label: $localize`Vision`,
      },
    }, {
      key: 'apiKeyTag',
      type: 'tag',
      props: {
        label: $localize`🔑️ API Key Tag:`,
        prefix: '+plugin/secret',
      },
    }, {
      key: 'model',
      type: 'string',
      props: {
        label: $localize`Model:`,
      },
    }, {
      key: 'systemPrompt',
      type: 'textarea',
      props: {
        label: $localize`System Prompt:`,
      },
    }, {
      key: 'maxTokens',
      type: 'number',
      props: {
        label: $localize`Max Tokens:`,
      },
    }, {
      key: 'thinking',
      type: 'boolean',
      defaultValue: false,
      props: {
        label: $localize`Thinking`,
      },
    }, {
      key: 'thinkingTokens',
      type: 'number',
      props: {
        label: $localize`Thinking Tokens:`,
      },
    }, {
      key: 'maxContext',
      type: 'number',
      props: {
        label: $localize`Max Context:`,
      },
    }, {
      key: 'maxSources',
      type: 'number',
      props: {
        label: $localize`Max Sources:`,
      },
    }, {
      key: 'ignoreThread',
    }, {
      key: 'json',
    }, {
      key: 'bundle',
      type: 'boolean',
      defaultValue: false,
      expressions: {
        hide: '!model.json',
      },
      props: {
        label: $localize`Any Response:`,
        title: $localize`If checked, the AI may return multiple responses including Exts.`,
      },
    }],
  },
  schema: {
    optionalProperties: {
      provider: { type: 'string' },
      apiKeyTag: { type: 'string' },
      model: { type: 'string' },
      ignoreThread: { type: 'boolean' },
      json: { type: 'boolean' },
      bundle: { type: 'boolean' },
      audio: { type: 'boolean' },
      vision: { type: 'boolean' },
      maxTokens: { type: 'uint32' },
      thinking: { type: 'boolean' },
      thinkingTokens: { type: 'uint32' },
      maxContext: { type: 'uint32' },
      maxSources: { type: 'uint32' },
      systemPrompt: { type: 'string' },
      usage: {
        optionalProperties: {
          promptTokens: { type: 'uint32' },
          completionTokens: { type: 'uint32' },
          totalTokens: { type: 'uint32' },
        }
      }
    },
  },
};

export const llmSearchPlugin: Plugin = {
  tag: 'plugin/llm/search',
  name: $localize`🔎️🌐️ AI Web Context`,
  config: {
    mod: $localize`✨️ AI Generation`,
    type: 'tool',
    default: false,
    inherit: false,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    icons: [
      { label: $localize`🔎️🌐️`, title: $localize`AI Web Context` },
    ],
  }
};

export const aliasPlugin: Plugin = {
  tag: 'plugin/alias',
  name: $localize`🎭️ Alias`,
  config: {
    mod: $localize`✨️ AI Generation`,
    type: 'tool',
    default: false,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`Add a signature tag without actually adding it.`,
    icons: [{ label: $localize`🎭️`, order: -1 }],
  },
};

export const aiMod: Mod = {
  plugin: [
    aiPlugin,
    aiQueryPlugin,
    llmPlugin,
    llmSearchPlugin,
    aliasPlugin,
  ],
};
