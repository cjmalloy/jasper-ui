import * as moment from 'moment';
import { Plugin } from '../model/plugin';
import { Mod } from '../model/tag';
import { Template } from '../model/template';

export const ninjaTrianglePlugin: Plugin = {
  tag: 'plugin/ninja.triangle',
  name: $localize`ü•∑üî∫Ô∏è Ninja Triangle`,
  config: {
    mod: $localize`ü•∑üî∫Ô∏è Ninja Triangle`,
    type: 'plugin',
    editingViewer: true,
    experimental: true,
    submitText: true,
    generated: $localize`Generated by jasper-ui ${moment().toISOString()}`,
    description: $localize`Create a Japanese Triangle and show the longest Ninja Path.`,
    aiInstructions: ` # plugin/ninjaTriangle
    Let $n$ be a positive integer. A *Japanese triangle* consists of $1 + 2 + \\ldots + n$ circles arranged in an
    equilateral triangular shape such that for each $i = 1, 2, \\ldots, n$, the $i$th row contains exactly $i$ circles,
    exactly one of which is coloured red. A *ninja path* in a Japanese triangle is a sequence of $n$ circles obtained by
    starting in the top row, then repeatedly going from a circle to one of the two circles immediately below it and
    finishing in the bottom row. Here is an example of a Japanese triangle with $n = 6$.

         r
        r o
       o o r
      o o r o
     o o o r o
    r o o o o o

    In terms of $n$, find the greatest $k$ such that in each Japanese triangle there is a ninja path containing at
    least $k$ red circles.
    `,
    icons: [{ label: $localize`üî∫Ô∏è`, order: 2 }],
    filters: [
      { query: 'plugin/ninja.triangle', label: $localize`ü•∑üî∫Ô∏è Ninja Triangle`, group: $localize`Plugins üß∞Ô∏è` },
    ],
    // language=HTML
    snippet: `
    <script>
      function read(text) {
        return (text || '')
          .split(/\\\s+/)
          .filter(n => !!n);
      }
      function write(t) {
        t = [...t];
        let text = '';
        const n = geometricSumInv(t.length);
        for (let i = 0; i < n; i++) {
          text += ' '.repeat(n - i);
          for (let j = 0; j <= i; j++) {
            text += ' ' + (t.shift() === 'r' ? 'r' : 'o');
          }
          text += '\\n';
        }
        return text;
      }
      function geometricSum(n) {
        return n * (n + 1) / 2;
      }
      function geometricSumInv(s) {
        return (Math.sqrt(8 * s + 1) - 1) / 2;
      }
      function bestNinjaPath(text, targetI, targetJ) {
        const triangle = read(text);
        if (targetI === undefined) targetI = geometricSumInv(triangle.length);
        function traverse(i, j, count) {
          if (i > targetI) return 0;
          const s = geometricSum(i);
          count += triangle[s + j] === 'r';
          if (i === targetI && j === targetJ) return count;
          return Math.max(traverse(i+1, j, count),
                          traverse(i+1, j+1, count))
        }
        return traverse(0, 0, 0)
      }
      Handlebars.registerHelper('ninjaTriangle', (comment, actions, el, d3) => () => {
        const triangle = read(comment);
        const n = geometricSumInv(triangle.length);
        const svg = d3.select(el).select('svg.japanese-triangle');
        const radius = 20;
        const spacing = 44;
        el.style.height = (n + 2) * spacing + 'px';

        function removeRow(text, n) {
          const t = read(text)
          for (let i = 0; i < n; i++) t.pop();
          text = write(t);
          actions.comment(text);
          return text;
        }

        function tagRed(text, i, j) {
          const t = read(text);
          const s = geometricSum(i - 1);
          for (let p = 0; p < i; p++) {
            t[s + p] = p === j ? 'r' : 'o';
          }
          text = write(t);
          actions.comment(text);
          return text;
        }

        let idx = 0;
        const ts = [...triangle];
        for (let i = 0; i <= n; i++) {
          for (let j = 0; j <= i; j++) {
            const cx = 300 + j * spacing - i * spacing / 2;
            const cy = 30 + i * spacing;
            const red = ts.shift() === 'r';
            const extraRow = i === n;

            const g = svg.append('g')
              .attr('transform', 'translate(' + cx + ',' + cy + ')');
            g.append('circle')
              .attr('r', radius)
              .attr('stroke', '#111')
              .attr('stroke-width', 2)
              .attr('fill', extraRow ? 'transparent'
                : red ? '#C33'
                : '#CCC')
              .on('click', function () {
                if (i === n) {
                  comment += '\\n' + Array(n).fill('o').join(' ');
                }
                comment = tagRed(comment, i + 1, j);
                // Remove any existing red circle in this row
                d3.selectAll('circle[row="' + (i + 1) + '"]').attr('fill', '#CCC');
                d3.selectAll('text[row="' + (i + 1) + '"]').text('');
                // Color the clicked circle red
                d3.select(this).attr('fill', '#C33');
                for (let i = 0; i < n; i++) {
                  for (let j = 0; j <= i; j++) {
                    d3.selectAll('text[row="' + (i + 1) + '"][col="' + (j + 1) + '"]').text(bestNinjaPath(comment, i, j));
                  }
                }
              })
              .on('contextmenu', function (event) {
                event.preventDefault();
                comment = removeRow(comment, n);
                d3.selectAll('circle[row="' + n + '"]').attr('fill', 'none');
                d3.selectAll('text[row="' + n + '"]').style('fill', 'none');
                d3.selectAll('circle[row="' + (n + 1) + '"]').attr('stroke', 'none');
              })
              .attr('row', (i + 1)); // custom attribute to indicate row number
            g.append('text')
              .text(red ? bestNinjaPath(comment, i, j) : '')
              .attr('stroke', 'none')
              .attr('fill', '#CCC')
              .attr('text-anchor', 'middle')
              .attr('alignment-baseline', 'middle')
              .style('font-size', '16px')
              .style('user-select', 'none')
              .attr('row', (i + 1)) // custom attribute to indicate row number
              .attr('col', (j + 1)); // custom attribute to indicate col number
            idx++;
          }
        }
      });
    </script>
    `,
    // language=CSS
    css: `
      .plugin_ninja-triangle.ui,
      .plugin_ninja-triangle.ui > *,
      .plugin_ninja-triangle.ui > * > *,
      .japanese-triangle {
        width: 100%;
        height: 100%;
      }
    `,
    // language=Handlebars
    ui: `
      <svg class="japanese-triangle">{{defer el (ninjaTriangle ref.comment actions el (d3))}}</svg>
    `,
  },
};

export const ninjaTriangleTemplate: Template = {
  tag: 'plugin/ninja.triangle',
  name: $localize`ü•∑üî∫Ô∏è Ninja Triangle`,
  config: {
    mod: $localize`ü•∑üî∫Ô∏è Ninja Triangle`,
    type: 'plugin',
    generated: 'Generated by jenkins-ui ' + moment().toISOString(),
    view: $localize`ü•∑üî∫Ô∏è`,
    // language=CSS
    css: `
      app-ref-list.plugin_ninja-triangle {
        .list-container {
          grid-auto-flow: row dense;
          padding: 4px;
          gap: 8px;
          grid-template-columns:  1fr;
          @media (min-width: 1000px) {
            grid-template-columns:  1fr 1fr;
          }
          @media (min-width: 1500px) {
            grid-template-columns: 1fr 1fr 1fr;
          }
          @media (min-width: 2000px) {
            grid-template-columns: 1fr 1fr 1fr 1fr;
          }
          .list-number {
            display: none;
          }
          .ref {
            break-inside: avoid;
            .toggle {
              display: none;
            }
            @media (max-width: 740px) {
              .actions, .info {
                height: 28px;
              }
            }
          }
        }
      }
    `,
  },
  defaults: {
    defaultExpanded: true,
    expandInline: false,
    defaultSort: 'modified,DESC',
    defaultCols: 0, // Leave to CSS screen size detection, but show cols dropdown
  }
};

export const ninjaTriangleMod: Mod = {
  plugins: {
    ninjaTrianglePlugin,
  },
  templates: {
    ninjaTriangleTemplate,
  },
};
