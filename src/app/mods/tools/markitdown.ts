import { DateTime } from 'luxon';
import { Plugin } from '../../model/plugin';
import { Mod } from '../../model/tag';

export const markitdownPlugin: Plugin = {
  tag: 'plugin/delta/md',
  name: $localize`‚¨áÔ∏è MarkItDown Query`,
  config: {
    mod: $localize`‚¨áÔ∏è MarkItDown`,
    type: 'tool',
    default: false,
    add: true,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`Convert documents to Markdown using Microsoft MarkItDown.
Supports PDF, Word, Excel, PowerPoint, images (with OCR), audio (transcription), HTML, and more.
Creates one response per supported format found.`,
    aiInstructions: `# plugin/delta/md
The MarkItDown plugin converts various file formats to Markdown text.
It uses the Microsoft markitdown Python library to process documents.

Supported formats (detected by plugin tags):
- plugin/pdf: PDF files
- plugin/image: Images (extracts text via OCR)
- plugin/audio: Audio files (transcribes to text)
- plugin/video: Video files (extracts audio and transcribes)
- plugin/file: Generic files (Word, Excel, PowerPoint, HTML, etc.)

The plugin creates one response Ref per supported format found on the source Ref.
Each response contains the converted Markdown in its comment field.
Resources are fetched through the Jasper proxy API.`,
    icons: [{ label: $localize`‚¨áÔ∏èüí≠Ô∏è`, order: -1 }],
    filters: [
      { query: 'plugin/delta/md', label: $localize`‚¨áÔ∏èüí≠Ô∏è markdown query`, title: $localize`Convert to Markdown`, group: $localize`Notifications ‚úâÔ∏è` },
    ],
    actions: [
      { tag: 'plugin/delta/md', labelOff: $localize`markdown`, title: $localize`Convert document to Markdown using MarkItDown`, global: true },
      { tag: 'plugin/delta/md', labelOn: $localize`cancel`, title: $localize`Cancel MarkItDown conversion.` },
    ],
    timeoutMs: 600_000,
    requirements: `
      markitdown[all]
      requests
    `,
    language: 'python',
    // language=python
    script: `
import json
import os
import sys
import tempfile
import uuid
import requests
from markitdown import MarkItDown, StreamInfo

ref = json.load(sys.stdin)
origin = ref.get('origin', '')
tags = ref.get('tags', [])

# Supported format plugins and their default file extensions
SUPPORTED_FORMATS = {
    'plugin/pdf': '.pdf',
    'plugin/image': '',  # Extension determined by URL or content-type
    'plugin/audio': '',  # Extension determined by URL or content-type
    'plugin/video': '',  # Extension determined by URL or content-type
    'plugin/file': '',   # Extension determined by URL or content-type
}

def has_tag(tag, tags):
    return tag in tags or any(t.startswith(tag + '/') for t in tags)

def get_extension_from_url(url):
    """Extract file extension from URL."""
    url_path = url.split('?')[0]
    if '.' in url_path.split('/')[-1]:
        return '.' + url_path.rsplit('.', 1)[-1].lower()
    return ''

def fetch_resource(url, resource_origin, ext=''):
    """Fetch resource through the Jasper proxy API using streaming to avoid memory issues."""
    # Normalize extension to ensure it starts with a dot
    if ext and not ext.startswith('.'):
        ext = '.' + ext

    proxy_url = f"{os.environ['JASPER_API']}/api/v1/proxy"
    response = requests.get(
        proxy_url,
        headers={
            'Local-Origin': origin or 'default',
            'User-Role': 'ROLE_ADMIN',
        },
        params={
            'url': url,
            'origin': resource_origin or '',
        },
        timeout=120,
        stream=True  # Enable streaming to avoid loading entire file into memory
    )
    response.raise_for_status()

    # Stream download to temporary file in chunks
    temp_file = None
    try:
        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=ext if ext else '')
        for chunk in response.iter_content(chunk_size=8192):
            if chunk:  # Filter out keep-alive chunks
                temp_file.write(chunk)
        temp_file.flush()  # Ensure all buffered data is written to disk
        temp_file.close()
        return temp_file.name, response.headers.get('content-type', '')
    except Exception as e:
        # Clean up temp file if download fails
        print(f"Error downloading resource from {url}: {e}", file=sys.stderr)
        if temp_file:
            temp_file.close()
            if os.path.exists(temp_file.name):
                os.remove(temp_file.name)
        raise

def convert_to_markdown(file_path, ext, content_type=''):
    """Convert file to markdown using MarkItDown."""
    # Extract mimetype from content-type (remove charset and other parameters)
    mimetype = None
    if content_type:
        mimetype = content_type.split(';')[0].strip()
        # Validate mimetype format
        if not mimetype or mimetype.count('/') != 1:
            mimetype = None

    # Create StreamInfo with mimetype and extension hints
    # MarkItDown uses these hints to identify the file format
    stream_info = None
    if mimetype or ext:
        stream_info = StreamInfo(
            mimetype=mimetype,
            extension=ext
        )

    try:
        md = MarkItDown()
        result = md.convert(file_path, stream_info=stream_info)
        return result.text_content
    finally:
        # Clean up the temporary file created by fetch_resource
        if os.path.exists(file_path):
            os.remove(file_path)

# Find all supported formats in the ref
formats_to_convert = []

for plugin_tag, default_ext in SUPPORTED_FORMATS.items():
    if has_tag(plugin_tag, tags):
        plugin_data = ref.get('plugins', {}).get(plugin_tag, {})
        url = plugin_data.get('url') if isinstance(plugin_data, dict) else None
        if not url:
            url = ref.get('url', '')
        if url:
            ext = default_ext or get_extension_from_url(url)
            formats_to_convert.append({
                'plugin': plugin_tag,
                'url': url,
                'ext': ext,
            })

# If no supported format tags found, check if ref URL has an extension
if not formats_to_convert:
    url = ref.get('url', '')
    if url:
        ext = get_extension_from_url(url)
        # Allow MarkItDown to attempt conversion of any file with an extension
        # Error handling in the conversion loop will catch unsupported formats
        if ext:
            formats_to_convert.append({
                'plugin': 'url',
                'url': url,
                'ext': ext,
            })

if not formats_to_convert:
    print("No supported formats found to convert", file=sys.stderr)
    sys.exit(0)

bundle = {'ref': []}

for fmt in formats_to_convert:
    try:
        url = fmt['url']
        ext = fmt['ext']
        plugin = fmt['plugin']

        # Fetch the resource through proxy with streaming
        file_path, content_type = fetch_resource(url, ref.get('origin', ''), ext)

        # Convert to markdown
        markdown_content = convert_to_markdown(file_path, ext, content_type)

        if not markdown_content or not markdown_content.strip():
            print(f"Warning: No content extracted from {plugin}", file=sys.stderr)
            markdown_content = f"(No text content could be extracted from {plugin})"

        # Create response ref with propagated tags (similar to dalle.ts pattern)
        response_ref_tags = ['+plugin/delta/md']

        # Propagate visibility/context tags from source ref
        if 'public' in tags:
            response_ref_tags.append('public')
        if 'internal' in tags:
            response_ref_tags.append('internal')
        if 'dm' in tags:
            response_ref_tags.extend(['dm', 'internal', 'plugin/thread'])
        if 'plugin/comment' in tags:
            response_ref_tags.extend(['plugin/comment', 'internal'])
        if 'plugin/thread' in tags:
            response_ref_tags.extend(['plugin/thread', 'internal'])

        # Propagate user tags (+user, _user, +user/*, _user/*)
        user_tags = [t[1:] for t in tags if t in ('+user', '_user') or t.startswith('+user/') or t.startswith('_user/')]

        # Propagate mailbox tags and create inbox tags for users
        mailbox_tags = [t for t in tags if t.startswith('plugin/inbox') or t.startswith('plugin/outbox')]
        response_ref_tags.extend(mailbox_tags)
        # Create inbox tags by removing the leading + or _ from user tags
        response_ref_tags.extend(['plugin/inbox/' + t for t in user_tags])
        if 'public' not in tags:
            response_ref_tags.extend(user_tags)
            response_ref_tags.extend([t for t in tags if t.startswith('user/')])

        # Remove duplicates while preserving order
        seen = set()
        unique_tags = []
        for t in response_ref_tags:
            if t not in seen:
                seen.add(t)
                unique_tags.append(t)
        response_ref_tags = unique_tags

        response_ref = {
            'origin': origin,
            'url': 'internal:' + str(uuid.uuid4()),
            'title': f"Markdown: {ref.get('title', 'Untitled')} ({plugin})",
            'comment': markdown_content,
            'tags': response_ref_tags,
            'sources': [ref.get('url')],
        }

        bundle['ref'].append(response_ref)

    except requests.exceptions.RequestException as e:
        print(f"Error fetching {fmt['plugin']}: {e}", file=sys.stderr)
    except Exception as e:
        print(f"Error converting {fmt['plugin']}: {e}", file=sys.stderr)

if bundle['ref']:
    print(json.dumps(bundle))
else:
    print("No content could be converted", file=sys.stderr)
    sys.exit(1)
    `,
  },
};

export const markitdownSignaturePlugin: Plugin = {
  tag: '+plugin/delta/md',
  name: $localize`‚¨áÔ∏è MarkItDown Result`,
  config: {
    mod: $localize`‚¨áÔ∏è MarkItDown`,
    type: 'tool',
    default: false,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`Signature tag for documents converted to Markdown using Microsoft MarkItDown.
Each response contains the converted Markdown from a specific source format.`,
    icons: [{ label: $localize`‚¨áÔ∏è`, order: 1 }],
    filters: [
      { query: '+plugin/delta/md', label: $localize`‚¨áÔ∏è markdown`, title: $localize`Converted to Markdown`, group: $localize`Delta Œî` },
    ],
    advancedActions: [
      { tag: '+plugin/delta/md', labelOn: $localize`reconvert`, title: $localize`Reconvert document to Markdown` },
      { tag: 'plugin/alias/plugin/delta/md', labelOff: $localize`reconvert`, title: $localize`Reconvert document to Markdown` },
    ],
  },
};

export const markitdownMod: Mod = {
  plugin: [
    markitdownPlugin,
    markitdownSignaturePlugin,
  ],
};
