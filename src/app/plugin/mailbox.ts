import { filter, maxBy, uniq } from 'lodash-es';
import * as moment from 'moment';
import { Plugin } from '../model/plugin';
import { Ref } from '../model/ref';
import { authors } from '../util/format';
import { hasPrefix, localTag, prefix, removePrefix, tagOrigin } from '../util/tag';

export const inboxPlugin: Plugin = {
  tag: 'plugin/inbox',
  name: $localize`âœ‰ï¸ Inbox`,
  config: {
    default: true,
    generated: $localize`Generated by jasper-ui ${moment().toISOString()}`,
    description: $localize`'The inbox plugin allow sending notifications to another user
      on the same server.'`,
    readAccess: ['plugin/inbox'],
  },
};

export const outboxPlugin: Plugin = {
  tag: 'plugin/outbox',
  name: $localize`ðŸ“¬ï¸ Outbox`,
  config: {
    default: true,
    generated: $localize`Generated by jasper-ui ${moment().toISOString()}`,
    description: $localize`The outbox plugin allow sending notifications to another user on
      a remote or multi-tenant server.`,
    icons: [{ label: $localize`ðŸ“¬ï¸`, title: $localize`Notifications in outbox` }],
    filters: [
      { query: 'plugin/outbox', label: $localize`ðŸ“¬ï¸ outbox`, group: $localize`Plugins ðŸ§°ï¸` },
    ],
  },
};

export function isMailbox(tag: string) {
  return tag.startsWith('plugin/inbox') ||
    tag.startsWith('plugin/outbox');
}

export function notifications(ref: Ref): string[] {
  return filter(ref.tags || [], isMailbox);
}

export function addressedTo(ref: Ref): string[] {
  return notifications(ref).map(getUser).filter(u => u) as string[];
}

export function getUser(mailbox: string): string | undefined {
  if (mailbox.startsWith('_plugin/inbox/')) return '_' + mailbox.substring('_plugin/inbox/'.length);
  if (mailbox.startsWith('plugin/inbox/')) return '+' + mailbox.substring('plugin/inbox/'.length);
  if (mailbox.startsWith('_plugin/outbox/')) return reverseOrigin('_' + mailbox.substring('_plugin/outbox/'.length));
  if (mailbox.startsWith('plugin/outbox/')) return reverseOrigin('+' + mailbox.substring('plugin/outbox/'.length));
  return undefined;
}

/**
 * Convert from reverse origin syntax (origin/user/tag) to qualified tag syntax (user/tag@origin).
 * @param tag
 */
export function reverseOrigin(tag: string): string {
  const len = tag.indexOf("/");
  return tag.substring(len + 1) + '@' + tag.substring(0, len);
}

export function getMailbox(tag: string, local = ''): string {
  if (hasPrefix(tag, 'plugin/inbox') || hasPrefix(tag, 'plugin/outbox')) return tag;
  if (hasPrefix(tag, 'plugin')) return tag;
  const origin = tagOrigin(tag);
  if (!origin || origin === local) {
    return prefix('plugin/inbox', localTag(tag));
  } else {
    return prefix(`plugin/outbox/${origin.substring(1)}`, localTag(tag));
  }
}

export function getLocalMailbox(mailbox: string, local: string, origin: string, lookup?: Map<string, Map<string, string>>) {
  if (!origin || origin === local) return mailbox;
  if (hasPrefix(mailbox, 'plugin/outbox')) {
    if (!lookup?.get(origin)) {
      console.warn('Cannot lookup mailbox translation for', origin);
      return undefined;
    }
    const remote = '@' + mailbox.split('/')[2];
    if (!lookup.get(origin)!.has(remote)) {
      console.warn('Cannot lookup mailbox translation for', origin, 'on remote', remote);
      return undefined;
    }
    const mapped = lookup.get(origin)!.get(remote);
    if (!mapped || mapped === local) {
      return 'plugin/inbox/' + removePrefix(mailbox, 3);
    }
    return `plugin/outbox/${mapped.substring(1)}/${removePrefix(mailbox, 3)}`;
  }
  if (hasPrefix(mailbox, 'plugin/inbox')) {
    return `plugin/outbox/${origin.substring(1)}/${removePrefix(mailbox, 2)}`;
  }
  throw 'not a mailbox';
}

export function mailboxes(ref: Ref, myUserTag: string, lookup?: Map<string, Map<string, string>>): string[] {
  const local = tagOrigin(myUserTag);
  return uniq([
    ...authors(ref).filter(tag => tag !== myUserTag).map(tag => getMailbox(tag, local)),
    ...notifications(ref).map(m => getLocalMailbox(m, local, ref.origin || '', lookup)).filter(t => !!t) as string[],
  ]);
}

export function newest(refs: Ref[]) {
  return maxBy(refs, r => r.modified!.valueOf());
}
